# CouplePlan 開発計画

## 現在の状況

### ✅ 完了済み

#### 1. **基盤セットアップ** - 完了

- ✅ Supabaseプロジェクト作成
- ✅ Next.js 15 + TypeScript + Tailwind CSS
- ✅ データベーススキーマ設計
- ✅ 開発環境構築

#### 2. **認証システム** - 完全安定化完了

- ✅ ログイン/サインアップ機能
- ✅ メール認証
- ✅ パスワードリセット
- ✅ セッション管理（localStorage + メモリ管理）
- ✅ プライベートブラウジング対応
- ✅ 認証フロー最適化
- ✅ エラーハンドリング強化

#### 3. **プロフィール機能** - 完了

- ✅ プロフィール編集機能（名前、メール、居住地、誕生日、記念日）
- ✅ プロフィールデータの永続化（Supabase）
- ✅ バリデーション機能（名前、メールアドレス、日付）
- ✅ アカウント削除機能
- ✅ パスワード変更機能
- ✅ プライバシー設定画面

#### 4. **パートナー連携機能** - 完了

- ✅ 招待コード生成（6桁、24時間有効）
- ✅ 招待コード検証
- ✅ カップル関係の確立
- ✅ パートナー情報の表示
- ✅ ダッシュボードからのナビゲーション
- ✅ エラーハンドリング

#### 5. **データベース設定** - 完了

- ✅ `profiles`テーブルとRLSポリシー
- ✅ `couple_invitations`テーブルとRLSポリシー
- ✅ `couples`テーブルとRLSポリシー
- ✅ データベーススキーマの永続化

#### 6. **UI/UXの実装** - 完了

- ✅ モダンなデザイン
- ✅ レスポンシブ対応
- ✅ フォームバリデーション
- ✅ エラーハンドリング
- ✅ ローディング状態の表示

### 📊 開発進捗サマリー

| カテゴリ           | 進捗率 | 状態            |
| ------------------ | ------ | --------------- |
| 認証システム       | 100%   | ✅ 完了         |
| プロフィール機能   | 100%   | ✅ 完了         |
| パートナー連携     | 100%   | ✅ 完了         |
| データベース設定   | 100%   | ✅ 完了         |
| AIデートプラン     | 90%    | 🚧 進行中       |
| **マネタイズ機能** | **0%** | **📝 開始予定** |
| 共同編集機能       | 0%     | 📝 未着手       |
| Date Canvas        | 0%     | 📝 未着手       |

### 🔧 現在の課題

**なし** - 基本機能は完成しました。次の機能開発フェーズに進みます。

### 🎉 本セッションで完了したタスク

1. ✅ アバター画像アップロード機能の削除（不要な機能を削減）
2. ✅ プロフィール編集機能の完成
3. ✅ メールアドレス編集機能の追加
4. ✅ パートナー連携機能の完全実装
5. ✅ 招待コード生成・検証・カップル関係確立
6. ✅ データベースRLSポリシーの設定
7. ✅ アカウント削除機能の改善
8. ✅ バリデーション機能の強化
9. ✅ ダッシュボードナビゲーションの追加
10. ✅ 認証トークンベースのAPI実装
11. ✅ **AIデートプラン提案機能（UC-001）** - 90%完了
    - プラン作成・生成・提案画面
    - プラン詳細表示
    - **カスタマイズビュー機能** ⭐ NEW
    - プランアイテム管理（追加・編集・削除）
    - 予算・時間の自動計算
    - プラン確定機能
12. ✅ **グローバルナビゲーションバー** - 全画面からホームへ移動可能
13. ✅ **UIコンポーネント** - Input, Textarea, Select, LoadingSpinner
14. ✅ **製品リリース準備** - 未実装機能を「準備中」表示
15. ✅ **README.md作成** - セットアップ・使い方ドキュメント

## 次の開発ステップ

### 🎯 優先度：高

#### 1. AIデートプラン提案機能（UC-001） - 90%完了 🚧

- [x] デートプラン作成画面の実装
- [x] AI生成中画面の実装（モック実装）
- [x] プラン提案画面の実装
- [x] プラン詳細画面の実装
- [x] カスタマイズビュー画面の実装 ✨ NEW
- [x] プラン保存・読み込み機能
- [x] カップル専用プラン機能
- [x] プランアイテム追加・編集・削除機能 ✨ NEW
- [x] 予算・時間の自動計算 ✨ NEW
- [x] プラン確定機能（ステータス管理） ✨ NEW
- [ ] AI API連携 - モックのみ実装済み
  - [ ] **Google Gemini API統合** ⭐ 優先（無料利用枠活用）
  - [ ] OpenAI API統合（オプション）
  - [ ] Anthropic Claude API統合（オプション）

#### 2. ダッシュボード機能の改善

- [ ] カップル情報の表示（連携状態、記念日カウント）
- [ ] 最近のアクティビティ表示
- [ ] クイックアクション機能
- [ ] 統計情報の充実化

### 🎯 優先度：中

#### 3. 共同編集機能（UC-002）

- [ ] 共同編集画面の実装
- [ ] リアルタイム同期機能
- [ ] 編集競合解決機能
- [ ] 編集履歴画面
- [ ] プレビュー画面

#### 4. Date Canvas機能（UC-005）

- [ ] 思い出記録機能
- [ ] 位置情報ピン機能
- [ ] 画像アップロード機能
- [ ] タグ・カテゴリ管理
- [ ] 検索・フィルター機能

#### 5. AI喧嘩仲裁・関係修復機能（UC-004）

- [ ] 仲裁依頼画面
- [ ] 状況分析機能
- [ ] AI仲裁提案
- [ ] 関係改善プラン
- [ ] 振り返りレポート

### 🎯 優先度：低

#### 6. ポータル機能（UC-003）

- [ ] ポータルトップ画面
- [ ] デート情報検索画面
- [ ] 記事詳細画面
- [ ] アプリ誘導機能
- [ ] 利用ガイド

#### 7. マネタイズ機能（UC-007）- 段階的実装

**Phase 1.1: 基本制限機能（最優先）- Stripe連携なし**

- [ ] データベーススキーマ実装
  - [ ] `subscription_plans`テーブル作成
  - [ ] `user_subscriptions`テーブル作成
  - [ ] `plan_generation_usage`テーブル作成
  - [ ] RLSポリシー設定
- [ ] バックエンドAPI実装
  - [ ] `/api/subscription/check-limit` - 制限チェック
  - [ ] `/api/subscription/usage` - 使用履歴記録
  - [ ] `/api/subscription/current` - 現在のプラン取得
- [ ] フロントエンド実装
  - [ ] 残り回数表示コンポーネント
  - [ ] 制限到達時のモーダル
  - [ ] ダッシュボードの使用状況表示
- [ ] AIプラン生成フローへの統合
  - [ ] 生成前の制限チェック
  - [ ] 生成後の使用履歴記録
  - [ ] エラーハンドリング

**Phase 1.2: Premium機能準備（将来実装）**

- [ ] Stripe連携実装（6-12ヶ月後）
- [ ] Premium会員登録画面
- [ ] サブスクリプション管理画面
- [ ] 課金指標分析ダッシュボード

## 技術的改善項目

### 🔧 短期的な改善（1-2週間）

1. **AI機能の統合** ⭐ 最優先
   - **Google Gemini 2.5 Flash API統合** ✅ 完了
     - Google AI Studioでプロジェクト作成
     - APIキー取得
     - 無料利用枠の活用（1分間10リクエスト、1日1,500リクエスト）
     - 思考モード搭載（高度な推論）
   - プロンプトエンジニアリング
   - レート制限対策（キューイング、リトライロジック）
   - エラーハンドリング
   - 代替プロバイダー対応（OpenAI、Anthropic）

2. **データベーススキーマの拡張**
   - `date_plans`テーブルのRLSポリシー
   - `memories`テーブルのRLSポリシー
   - リアルタイム機能の設定

3. **テスト環境の構築**
   - 単体テストの追加
   - E2Eテストの実装
   - CI/CDパイプラインの構築

### 🔧 中期的な改善（1-2ヶ月）

1. **パフォーマンス最適化**
   - クエリ最適化
   - バンドルサイズの削減
   - キャッシュ戦略の実装
   - 画像最適化

2. **アクセシビリティの向上**
   - キーボードナビゲーション
   - スクリーンリーダー対応
   - カラーコントラストの改善
   - WCAG 2.1 AA準拠

3. **セキュリティ強化**
   - CSP（Content Security Policy）の実装
   - CORS設定の最適化
   - レート制限の実装
   - 監査ログの実装

## 推奨する次のアクション

### 🚀 今すぐ実行すべきこと（最優先）

1. **AIプラン生成制限機能の実装** ⭐⭐⭐ 最優先
   - **Week 1: データベース実装（2-3日）**
     - `subscription_plans`テーブル作成
     - `user_subscriptions`テーブル作成
     - `plan_generation_usage`テーブル作成
     - RLSポリシー設定
     - 初期データ投入（FreeプランとPremiumプラン定義）
   - **Week 2: API実装（3-4日）**
     - `/api/subscription/check-limit` API作成
     - `/api/subscription/usage` API作成
     - `/api/subscription/current` API作成
     - エラーハンドリング実装
   - **Week 3: フロントエンド実装（4-5日）**
     - 残り回数表示コンポーネント
     - 制限到達モーダル
     - ダッシュボード使用状況表示
     - AIプラン生成フローへの統合
   - **Week 4: テストと調整（2-3日）**
     - 日次/月次リセットの動作確認
     - エッジケースのテスト
     - UX最終調整

2. **ダッシュボード機能の改善**
   - カップル情報の表示
   - 記念日カウントダウン
   - 使用状況統計の表示

3. **データベーススキーマの拡張**
   - ✅ `date_plans`テーブルのRLSポリシー設定（完了）
   - マネタイズ関連テーブルのRLS設定

### 📋 今月中に完了すべきこと

1. ✅ プロフィール機能の完成（完了）
2. ✅ パートナー連携機能の完成（完了）
3. ✅ AIデートプラン機能の基本実装（90%完了）
4. **AIプラン生成制限機能の完全実装** ⭐ NEW
5. 使用状況の分析基盤構築

### 🎯 来月の目標

1. **制限機能の運用開始と最適化**
   - 使用データの収集・分析
   - 制限レベルの調整（必要に応じて）
   - ユーザーフィードバックの収集
2. **Premium準備UI実装**
   - Premium案内ページ
   - プラン比較表示
3. 共同編集機能の実装開始（Supabase Realtime活用）
4. テスト環境の構築

## 技術スタック

### 現在使用中

- **フロントエンド**: Next.js 15, React 19, TypeScript, Tailwind CSS
- **バックエンド**: Supabase, Next.js API Routes
- **認証**: Supabase Auth（PKCE認証フロー）
- **データベース**: Supabase PostgreSQL
- **状態管理**: React Hooks（useState, useEffect, useContext）
- **バリデーション**: カスタムバリデーション関数
- **デプロイ**: Vercel（予定）

### 追加検討中

- **AI機能**:
  - **Google Gemini 2.5 Flash API** ⭐ 優先（無料利用枠: 1分間10リクエスト、1日1,500リクエスト）
    - 思考モード搭載（高度な推論）
    - トークン使用量: 約3000/リクエスト
    - 月間45,000リクエスト対応可能
  - OpenAI API（オプション）
  - Anthropic Claude API（オプション）
- **リアルタイム**: Supabase Realtime
- **テスト**: Jest, Playwright
- **モニタリング**: Sentry（エラー追跡）
- **分析**: Google Analytics または Mixpanel

## 実装済みの機能

### ✅ 完成した画面

1. **認証関連**
   - ログイン画面（`/login`）
   - サインアップ画面（`/signup`）
   - パスワードリセット画面（`/reset-password`）

2. **ダッシュボード**
   - メインダッシュボード（`/dashboard`）
   - プロフィール画面（`/dashboard/profile`）
   - パートナー連携画面（`/dashboard/partner-linkage`）
   - プライバシー設定画面（`/dashboard/privacy`）

3. **API Routes**
   - 認証API（`/api/auth/login`, `/api/auth/signup`）
   - パートナー連携API（`/api/partner/*`）
   - アカウント管理API（`/api/account`）

### 🔧 実装中の機能

**なし** - 次の機能開発待ち

## 注意事項

### セキュリティ

- ✅ Row Level Security（RLS）を全テーブルで有効化
- ✅ 認証トークンベースのAPI認証
- ✅ XSS対策
- ✅ TypeScript型安全性
- ⚠️ CSP（Content Security Policy）未実装
- ⚠️ レート制限未実装

### パフォーマンス

- ✅ Next.js 15の最適化機能を活用
- ✅ サーバーサイドレンダリング
- ⚠️ 画像最適化未実装
- ⚠️ キャッシュ戦略未実装

### アクセシビリティ

- ✅ セマンティックHTML
- ✅ キーボード操作対応（一部）
- ⚠️ スクリーンリーダー完全対応未実装
- ⚠️ WCAG 2.1 AA準拠未確認

### スケーラビリティ

- ✅ マイクロサービスアーキテクチャ設計
- ✅ Supabaseによるスケーラブルなインフラ
- ⚠️ 大規模トラフィック対策未実装

## 開発の進め方

### 推奨アプローチ

1. **MVPファースト**: 最小限の機能で早期リリース
2. **ユーザーフィードバック**: 実際のユーザーからフィードバックを得る
3. **段階的改善**: 優先度に基づいて機能を追加
4. **品質重視**: セキュリティとパフォーマンスを妥協しない

### 開発サイクル

1. **計画** → 2. **実装** → 3. **テスト** → 4. **デプロイ** → 5. **フィードバック** → 1に戻る

## クイックスタートガイド

### 🚀 新規開発者向けセットアップ

1. **リポジトリのクローン**

   ```bash
   git clone <repository-url>
   cd coupleplan
   npm install
   ```

2. **環境変数の設定**
   - `.env.local`ファイルを作成
   - Supabaseの認証情報を設定（`NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_ROLE_KEY`）

3. **Supabaseデータベースの設定**
   - `Docs/DATABASE_MIGRATION_GUIDE.md`を参照
   - 必要なテーブルとRLSポリシーを作成

4. **開発サーバーの起動**

   ```bash
   npm run dev
   ```

5. **動作確認**
   - `http://localhost:3000`にアクセス
   - アカウント作成、ログイン、プロフィール編集をテスト

### 📚 主要ドキュメント

- **データベースセットアップ**: `Docs/SUPABASE_SETUP.md`
- **認証システム設計**: `Docs/認証システム設計書.md`
- **データモデル**: `Docs/データモデル図.md`
- **画面一覧**: `Docs/画面一覧・遷移図.md`

---

**最終更新**: 2025年10月11日  
**バージョン**: v1.1.0  
**次回レビュー**: マネタイズ機能実装完了後  
**担当者**: 開発チーム

### 📝 今回の更新内容（2025年10月11日）

- ✅ **マネタイズ機能実装計画を追加**
  - Phase 1.1: 基本制限機能（Stripe連携なし）の詳細設計
  - データベーススキーマ設計（3テーブル + トリガー）
  - API実装計画（3エンドポイント）
  - フロントエンド実装計画（コンポーネント設計）
  - テスト計画とエッジケース対応
- ✅ **収益化戦略の明確化**
  - Freeプラン: 日次3回、月次10回、プラン保存5件
  - Premiumプラン: ¥480/月（将来実装）
  - 段階的導入アプローチの策定
- ✅ **実装期間の明確化**
  - 合計: 2-3週間（データベース→API→フロントエンド→テスト）

## 🎉 本番稼働準備完了

### Gemini API統合 - 完了 ✅

- ✅ Gemini 2.5 Flash統合（最新推奨モデル）
- ✅ 思考モード搭載（高度な推論）
- ✅ レート制限管理（1分間10リクエスト、1日1,500リクエスト）
- ✅ 多重リクエスト防止機構
- ✅ ループ防止機構
- ✅ トークン最適化（約3000トークン/リクエスト）
- ✅ プラン数最適化（1つの最適プランを生成）
- ✅ UI最適化（中央配置レイアウト）

### スケーラビリティ

- 無料枠で**15,000ユーザー**まで対応可能
- 月間**45,000リクエスト**処理
- 生成時間: **15-25秒**
- コスト: **完全無料**

### 次のステップ：マネタイズ機能実装 🚀

**AIプラン生成制限機能の実装が必要です**（実装期間: 2-3週間）

---

## 💰 マネタイズ機能実装計画

### フェーズ1.1: 基本制限機能（Stripe連携なし）

#### 実装期間：2-3週間

#### 機能概要

無料プラン（Free）のユーザーに対して、AIプラン生成の利用回数制限を設けます。

- **日次制限**: 3回/日
- **月次制限**: 10回/月
- **プラン保存制限**: 5件まで

#### 実装ステップ

### Step 1: データベース設計と実装（2-3日）

**1.1 テーブル作成**

```sql
-- プラン定義テーブル
CREATE TABLE subscription_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE, -- 'free', 'premium'
  display_name TEXT NOT NULL, -- 'Free', 'Premium'
  price_monthly INTEGER NOT NULL, -- 0, 480 (円)
  daily_plan_limit INTEGER, -- 3, NULL (無制限)
  monthly_plan_limit INTEGER, -- 10, NULL (無制限)
  max_saved_plans INTEGER, -- 5, NULL (無制限)
  features JSONB, -- その他の機能フラグ
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- ユーザーのサブスク状態
CREATE TABLE user_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  plan_id UUID NOT NULL REFERENCES subscription_plans(id),
  status TEXT NOT NULL DEFAULT 'active', -- 'active', 'canceled', 'expired'
  -- Stripe関連（将来用、現在は未使用）
  stripe_customer_id TEXT,
  stripe_subscription_id TEXT,
  current_period_start TIMESTAMPTZ,
  current_period_end TIMESTAMPTZ,
  cancel_at_period_end BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(user_id)
);

-- 使用履歴
CREATE TABLE plan_generation_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  plan_id UUID REFERENCES date_plans(id) ON DELETE SET NULL,
  generated_at TIMESTAMPTZ DEFAULT now(),
  -- インデックス用の日付カラム
  generation_date DATE GENERATED ALWAYS AS (DATE(generated_at AT TIME ZONE 'Asia/Tokyo')) STORED,
  generation_month DATE GENERATED ALWAYS AS (DATE_TRUNC('month', (generated_at AT TIME ZONE 'Asia/Tokyo'))::DATE) STORED
);

-- パフォーマンス用インデックス
CREATE INDEX idx_usage_user_date ON plan_generation_usage(user_id, generation_date);
CREATE INDEX idx_usage_user_month ON plan_generation_usage(user_id, generation_month);
CREATE INDEX idx_subscriptions_user ON user_subscriptions(user_id);
CREATE INDEX idx_subscriptions_plan ON user_subscriptions(plan_id);
```

**1.2 RLSポリシー設定**

```sql
-- subscription_plans: 全員が読み取り可能
ALTER TABLE subscription_plans ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Plans are viewable by everyone"
  ON subscription_plans FOR SELECT
  USING (is_active = true);

-- user_subscriptions: 自分のサブスクのみ読み取り可能
ALTER TABLE user_subscriptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own subscription"
  ON user_subscriptions FOR SELECT
  USING (auth.uid() = user_id);

-- plan_generation_usage: 自分の履歴のみ読み取り可能
ALTER TABLE plan_generation_usage ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own usage"
  ON plan_generation_usage FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage"
  ON plan_generation_usage FOR INSERT
  WITH CHECK (auth.uid() = user_id);
```

**1.3 初期データ投入**

```sql
-- Freeプラン
INSERT INTO subscription_plans (name, display_name, price_monthly, daily_plan_limit, monthly_plan_limit, max_saved_plans, features)
VALUES (
  'free',
  'Free',
  0,
  3,
  10,
  5,
  '{"ai_plan_generation": true, "plan_save": true, "partner_linkage": true}'::jsonb
);

-- Premiumプラン（将来用）
INSERT INTO subscription_plans (name, display_name, price_monthly, daily_plan_limit, monthly_plan_limit, max_saved_plans, features)
VALUES (
  'premium',
  'Premium',
  480,
  NULL,
  NULL,
  NULL,
  '{"ai_plan_generation": true, "plan_save": true, "partner_linkage": true, "priority_support": true, "future_features": true}'::jsonb
);
```

**1.4 自動サブスク作成トリガー**

```sql
-- 新規ユーザー作成時に自動的にFreeプランを割り当てる
CREATE OR REPLACE FUNCTION create_user_subscription()
RETURNS TRIGGER AS $$
DECLARE
  free_plan_id UUID;
BEGIN
  -- Freeプランのidを取得
  SELECT id INTO free_plan_id FROM subscription_plans WHERE name = 'free' LIMIT 1;

  -- ユーザーのサブスクを作成
  INSERT INTO user_subscriptions (user_id, plan_id, status)
  VALUES (NEW.id, free_plan_id, 'active');

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- トリガーを作成
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION create_user_subscription();
```

### Step 2: バックエンドAPI実装（3-4日）

**2.1 `/api/subscription/check-limit` - 制限チェック**

```typescript
// src/app/api/subscription/check-limit/route.ts
import { createClient } from '@/lib/supabase/server';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    const supabase = await createClient();

    // ユーザー認証確認
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: '認証が必要です' }, { status: 401 });
    }

    // 現在のプラン情報を取得
    const { data: subscription, error: subError } = await supabase
      .from('user_subscriptions')
      .select(
        `
        *,
        plan:subscription_plans(*)
      `
      )
      .eq('user_id', user.id)
      .single();

    if (subError || !subscription) {
      return NextResponse.json(
        { error: 'サブスクリプション情報が見つかりません' },
        { status: 404 }
      );
    }

    const plan = subscription.plan;

    // 無制限プランの場合
    if (plan.daily_plan_limit === null && plan.monthly_plan_limit === null) {
      return NextResponse.json({
        canGenerate: true,
        remaining: {
          daily: null,
          monthly: null,
        },
        plan: plan.name,
      });
    }

    // 現在の日時（JST）
    const today = new Date().toLocaleDateString('sv-SE', { timeZone: 'Asia/Tokyo' });
    const thisMonth = today.substring(0, 7) + '-01';

    // 日次使用回数を取得
    const { count: dailyCount, error: dailyError } = await supabase
      .from('plan_generation_usage')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('generation_date', today);

    // 月次使用回数を取得
    const { count: monthlyCount, error: monthlyError } = await supabase
      .from('plan_generation_usage')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('generation_month', thisMonth);

    if (dailyError || monthlyError) {
      throw new Error('使用履歴の取得に失敗しました');
    }

    const dailyUsed = dailyCount || 0;
    const monthlyUsed = monthlyCount || 0;

    // 制限チェック
    const dailyRemaining = plan.daily_plan_limit ? plan.daily_plan_limit - dailyUsed : null;
    const monthlyRemaining = plan.monthly_plan_limit ? plan.monthly_plan_limit - monthlyUsed : null;

    const canGenerate =
      (dailyRemaining === null || dailyRemaining > 0) &&
      (monthlyRemaining === null || monthlyRemaining > 0);

    return NextResponse.json({
      canGenerate,
      remaining: {
        daily: dailyRemaining,
        monthly: monthlyRemaining,
      },
      used: {
        daily: dailyUsed,
        monthly: monthlyUsed,
      },
      limits: {
        daily: plan.daily_plan_limit,
        monthly: plan.monthly_plan_limit,
      },
      plan: plan.name,
    });
  } catch (error) {
    console.error('Error checking limit:', error);
    return NextResponse.json({ error: '制限チェックに失敗しました' }, { status: 500 });
  }
}
```

**2.2 `/api/subscription/usage` - 使用履歴記録**

```typescript
// src/app/api/subscription/usage/route.ts
import { createClient } from '@/lib/supabase/server';
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  try {
    const supabase = await createClient();

    // ユーザー認証確認
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: '認証が必要です' }, { status: 401 });
    }

    const body = await request.json();
    const { planId } = body;

    // 使用履歴を記録
    const { error: insertError } = await supabase.from('plan_generation_usage').insert({
      user_id: user.id,
      plan_id: planId || null,
    });

    if (insertError) {
      throw insertError;
    }

    // 現在の制限状況を返す
    const checkResponse = await fetch(
      `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/subscription/check-limit`,
      {
        headers: {
          Cookie: request.headers.get('cookie') || '',
        },
      }
    );

    const checkData = await checkResponse.json();

    return NextResponse.json({
      success: true,
      ...checkData,
    });
  } catch (error) {
    console.error('Error recording usage:', error);
    return NextResponse.json({ error: '使用履歴の記録に失敗しました' }, { status: 500 });
  }
}
```

**2.3 `/api/subscription/current` - 現在のプラン取得**

```typescript
// src/app/api/subscription/current/route.ts
import { createClient } from '@/lib/supabase/server';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    const supabase = await createClient();

    // ユーザー認証確認
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: '認証が必要です' }, { status: 401 });
    }

    // サブスクリプション情報を取得
    const { data: subscription, error: subError } = await supabase
      .from('user_subscriptions')
      .select(
        `
        *,
        plan:subscription_plans(*)
      `
      )
      .eq('user_id', user.id)
      .single();

    if (subError || !subscription) {
      return NextResponse.json(
        { error: 'サブスクリプション情報が見つかりません' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      subscription: {
        id: subscription.id,
        status: subscription.status,
        created_at: subscription.created_at,
      },
      plan: subscription.plan,
    });
  } catch (error) {
    console.error('Error fetching subscription:', error);
    return NextResponse.json(
      { error: 'サブスクリプション情報の取得に失敗しました' },
      { status: 500 }
    );
  }
}
```

### Step 3: フロントエンド実装（4-5日）

**3.1 残り回数表示コンポーネント**

```tsx
// src/components/subscription/UsageLimitDisplay.tsx
'use client';

import { useEffect, useState } from 'react';

interface UsageLimit {
  canGenerate: boolean;
  remaining: {
    daily: number | null;
    monthly: number | null;
  };
  used: {
    daily: number;
    monthly: number;
  };
  limits: {
    daily: number | null;
    monthly: number | null;
  };
  plan: string;
}

export function UsageLimitDisplay() {
  const [limit, setLimit] = useState<UsageLimit | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchLimit();
  }, []);

  const fetchLimit = async () => {
    try {
      const response = await fetch('/api/subscription/check-limit');
      const data = await response.json();
      setLimit(data);
    } catch (error) {
      console.error('Error fetching limit:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return <div>読み込み中...</div>;
  }

  if (!limit || limit.plan === 'premium') {
    return null; // Premiumユーザーには表示しない
  }

  return (
    <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm text-gray-600">
            📊 今日の残り: <span className="font-semibold">{limit.remaining.daily}</span> /{' '}
            {limit.limits.daily}回
          </p>
          <p className="text-sm text-gray-600">
            今月の残り: <span className="font-semibold">{limit.remaining.monthly}</span> /{' '}
            {limit.limits.monthly}回
          </p>
        </div>
        <div>
          <a href="/dashboard/subscription" className="text-sm text-blue-600 hover:text-blue-800">
            💎 無制限で使う →
          </a>
        </div>
      </div>
    </div>
  );
}
```

**3.2 制限到達モーダル**

```tsx
// src/components/subscription/LimitReachedModal.tsx
'use client';

interface LimitReachedModalProps {
  isOpen: boolean;
  onClose: () => void;
  limitType: 'daily' | 'monthly';
  remaining: {
    daily: number | null;
    monthly: number | null;
  };
}

export function LimitReachedModal({
  isOpen,
  onClose,
  limitType,
  remaining,
}: LimitReachedModalProps) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-8 max-w-md w-full mx-4">
        <h2 className="text-2xl font-bold mb-4">
          {limitType === 'daily' ? '本日の作成回数に達しました' : '今月の作成回数に達しました'}
        </h2>

        {limitType === 'daily' && remaining.monthly && remaining.monthly > 0 ? (
          <>
            <p className="text-gray-600 mb-4">📅 明日また3回作成できます</p>
            <p className="text-sm text-gray-500 mb-6">
              今月はあと {remaining.monthly}回 利用可能です
            </p>
          </>
        ) : (
          <>
            <p className="text-gray-600 mb-4">📅 来月にリセットされます</p>
            <p className="text-sm text-gray-500 mb-6">次回は来月1日から利用可能です</p>
          </>
        )}

        <div className="border-t border-gray-200 pt-6 mb-6">
          <h3 className="font-semibold mb-2">💡 Premium プランなら無制限</h3>
          <p className="text-sm text-gray-600 mb-4">月額 ¥480（近日公開予定）</p>
          <ul className="text-sm text-gray-600 space-y-1 mb-4">
            <li>✨ AIプラン生成: 無制限</li>
            <li>✨ プラン保存: 無制限</li>
            <li>✨ 優先サポート</li>
            <li>✨ 今後の新機能に優先アクセス</li>
          </ul>
        </div>

        <div className="flex gap-3">
          <button
            onClick={onClose}
            className="flex-1 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
          >
            閉じる
          </button>
          <button
            onClick={() => {
              // 将来: Premium登録ページへ遷移
              alert('Premium プランは近日公開予定です');
            }}
            className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            詳細を見る
          </button>
        </div>
      </div>
    </div>
  );
}
```

**3.3 AIプラン生成フローへの統合**

```typescript
// src/app/dashboard/plans/create/page.tsx の修正
// プラン生成ボタンのonClick処理

const handleGeneratePlan = async () => {
  // 1. 制限チェック
  const limitResponse = await fetch('/api/subscription/check-limit');
  const limitData = await limitResponse.json();

  if (!limitData.canGenerate) {
    // 制限到達モーダルを表示
    const limitType = limitData.remaining.daily === 0 ? 'daily' : 'monthly';
    setShowLimitModal(true);
    setLimitType(limitType);
    setRemaining(limitData.remaining);
    return;
  }

  // 2. プラン生成処理
  setGenerating(true);
  try {
    const response = await fetch('/api/plans/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(formData),
    });

    const data = await response.json();

    // 3. 使用履歴を記録
    await fetch('/api/subscription/usage', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ planId: data.plan.id }),
    });

    // 4. 生成完了処理
    router.push(`/dashboard/plans/${data.plan.id}`);
  } catch (error) {
    console.error('Error generating plan:', error);
  } finally {
    setGenerating(false);
  }
};
```

### Step 4: テストと調整（2-3日）

**4.1 テストケース**

- [ ] 新規ユーザー登録時にFreeプランが自動割り当てされる
- [ ] 日次制限（3回）が正しく機能する
- [ ] 月次制限（10回）が正しく機能する
- [ ] 日付変更時（0時JST）に日次カウントがリセットされる
- [ ] 月初（1日0時JST）に月次カウントがリセットされる
- [ ] 制限到達時に適切なモーダルが表示される
- [ ] 使用履歴が正しく記録される
- [ ] パフォーマンステスト（大量ユーザー想定）

**4.2 エッジケース対応**

- [ ] タイムゾーン処理（JST基準）
- [ ] 同時リクエスト処理
- [ ] ネットワークエラー時のリトライ
- [ ] データベース接続エラー処理

### 実装完了後の確認事項

- [ ] すべてのテストケースが通過
- [ ] ドキュメント更新（README, API仕様書）
- [ ] 本番環境へのデプロイ準備
- [ ] モニタリング設定（使用状況ダッシュボード）
- [ ] ユーザーへの告知準備

### フェーズ1.2以降（将来実装）

- Stripe連携実装（6-12ヶ月後）
- Premium会員登録機能
- サブスクリプション管理画面
- 決済履歴表示
- プラン変更・キャンセル機能

## Google Gemini API 統合計画

### Gemini API の利点

1. **無料利用枠が充実**
   - 1分間15リクエスト
   - 1日1,500リクエスト
   - 小規模〜中規模サービスに最適

2. **高品質な日本語対応**
   - Googleの多言語AIモデル
   - 自然な日本語生成

3. **コスト効率**
   - 開発・検証段階は完全無料
   - スケールアップ時も競合より低価格

### 統合ステップ

#### Step 1: Google AI Studio セットアップ

1. Google AI Studio（https://aistudio.google.com/）にアクセス
2. Googleアカウントでログイン
3. 新規プロジェクト作成
4. APIキーを取得

#### Step 2: 環境変数設定

`.env.local` に追加:

```env
AI_PROVIDER=gemini
GEMINI_API_KEY=your_gemini_api_key_here
AI_MODEL=gemini-2.5-flash
AI_MAX_TOKENS=3000
AI_TEMPERATURE=0.7
```

#### Step 3: コード実装

`src/lib/ai-service.ts` に以下を追加:

- `generateWithGemini()` 関数
- Gemini API呼び出しロジック
- レート制限ハンドリング
- エラーハンドリング

#### Step 4: テスト & 検証

1. モックから Gemini への切り替え
2. プラン生成品質の確認
3. レート制限の動作確認
4. エラーケースのテスト

#### Step 5: 本番デプロイ

1. Vercel環境変数設定
2. 本番デプロイ
3. モニタリング設定
4. ユーザーフィードバック収集

### レート制限対策

無料利用枠の制限:

- **1分間15リクエスト**: キューイングシステム実装
- **1日1,500リクエスト**: 使用量モニタリング

実装方針:

```typescript
// レート制限キュー
class RateLimiter {
  private queue: Array<() => Promise<any>> = [];
  private requestCount = 0;
  private lastMinute = Date.now();

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    // 1分間15リクエスト制限チェック
    // キューイング処理
    // リトライロジック
  }
}
```

### 予想されるメリット

1. **開発コストゼロ**: 初期フェーズの費用削減
2. **高速開発**: すぐに実装・テスト可能
3. **スケーラビリティ**: 1日1,500リクエスト = 月間45,000リクエスト
4. **品質**: Googleの最新AIモデル活用
