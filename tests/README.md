# Couple Plan テスト戦略

このプロジェクトでは、以下の2つのレベルでテストを実施しています：

## 1. ユニットテスト (`tests/unit/`)

個々のコンポーネントや関数の動作を検証するテストです。

- **対象**: 関数、コンポーネント、ユーティリティ
- **ツール**: Jest, React Testing Library
- **実行コマンド**: `npm run test:unit`

## 2. インテグレーションテスト (`tests/integration/`)

複数のコンポーネントやAPIの連携、およびフロントエンドの動作を検証するテストです。

- **対象**: 
  - APIエンドポイント
  - 複合コンポーネント
  - データフロー
  - ユーザーインターフェース
  - フォーム検証
  - 画面遷移
- **ツール**: Jest, React Testing Library, Fetch Mock, jsdom
- **実行コマンド**: `npm run test:integration`

## テスト実行方法

### ローカル環境での実行

```bash
# すべてのテストを実行
npm run test

# ユニットテストのみ実行
npm run test:unit

# インテグレーションテストのみ実行
npm run test:integration
```

### CI環境での実行

GitHub Actionsで自動的に実行されます。各テストタイプは別々のジョブとして実行され、並列処理されます。

## テストカバレッジ

テストカバレッジレポートを生成するには：

```bash
npm run test:coverage
```

インテグレーションテストでは自動的にカバレッジレポートが生成されます：

```bash
npm run test:integration
```

## モックの使用方法

テストでは以下のモックを使用しています：

1. **APIモック**: `jest-fetch-mock`を使用してAPIリクエストをモック化
2. **Supabaseモック**: 認証機能をモック化
3. **Prismaモック**: データベース操作をモック化
4. **jsdomモック**: ブラウザ環境をシミュレート

## フロントエンドテスト戦略

インテグレーションテストでは、以下の観点でフロントエンドのテストを強化しています：

1. **コンポーネントテスト**: 個々のUIコンポーネントの動作検証
2. **フォームバリデーション**: 入力検証ロジックのテスト
3. **ユーザーインタラクション**: クリック、入力、送信などのユーザー操作のシミュレーション
4. **状態管理**: コンポーネント間の状態共有と更新のテスト
5. **レンダリング**: 条件付きレンダリングと動的コンテンツのテスト
6. **エラーハンドリング**: エラー状態の表示と処理のテスト

## テスト作成のガイドライン

新しいテストを追加する際は、以下のガイドラインに従ってください：

1. **テスト分類**: 適切なディレクトリ（unit/integration）にテストを配置
2. **命名規則**: テストファイル名は対象の機能名に合わせる（例: `login.test.tsx`）
3. **テスト構造**: `describe`と`it`を使用して階層的に構造化
4. **アサーション**: 明確で具体的なアサーションを使用
5. **モック**: 外部依存はモック化して分離テスト
6. **ユーザー視点**: 実際のユーザー操作を模倣したテストを作成

## フロントエンドテストのベストプラクティス

1. **セレクタの優先順位**:
   - ユーザーが見える要素を優先（テキスト、ラベル、役割）
   - データ属性（`data-testid`）は最後の手段として使用

2. **ユーザー操作のシミュレーション**:
   - `userEvent`を使用して実際のユーザー操作を模倣
   - 単純なイベント発火よりも実際の操作を優先

3. **非同期処理の扱い**:
   - `waitFor`や`findBy*`を使用して非同期更新を待機
   - タイムアウトは適切に設定

4. **テストの独立性**:
   - 各テストは独立して実行できるようにする
   - テスト間で状態が漏れないようにする

5. **スナップショットテスト**:
   - 大きなコンポーネントツリーではなく、小さなコンポーネントに対して使用
   - 頻繁に変更される部分には使用しない 